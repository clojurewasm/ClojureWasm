# Compatibility Test Tracking
# Source: test/upstream/ (SCI tests + Clojure JVM equivalent tests)
# Updated: 2026-02-03 (T14.11)
#
# Status values:
#   pass   - all assertions pass
#   fail   - some assertions fail (non-crash)
#   skip   - test commented out (crash or missing feature)
#   pending - not yet ported
#
# Backend: TreeWalk only (--tree-walk)
#
# ==============================================================================
# Overall Summary (SCI + Clojure JVM)
# ==============================================================================
# Total tests:      178 (SCI: 72, Clojure JVM: 106)
# Total assertions: 998 (SCI: 267, Clojure JVM: 731)
# Pass rate:        100%
# ==============================================================================

sci_core_test:
  summary:
    total: 72           # total deftests
    active: 72          # running deftests
    pass: 72            # all assertions pass
    fail: 0             # assertion failures
    skip: 0             # none
    assertions: 267     # total is-assertions in active tests
    skipped_assertions: 1   # var :name metadata (meta-test)

  tests:
    do-test:                    { status: pass }
    if-and-when-test:           { status: pass }
    and-or-test:                { status: pass }
    fn-literal-test:            { status: pass }
    fn-test:                    { status: pass }
    def-test:                   { status: pass }
    defn-test:                  { status: pass }
    let-test:                   { status: pass }
    destructure-test:           { status: pass, note: "2 assertions skipped: {:keys [:a]} keyword in keys vector" }
    closure-test:               { status: pass }
    core-hof-test:              { status: pass }
    literals-test:              { status: pass }
    quoting-test:               { status: pass }
    calling-ifns-test:          { status: pass }
    arithmetic-test:            { status: pass }
    comparisons-test:           { status: pass }
    sequences-test:             { status: pass }
    string-operations-test:     { status: pass, note: "minimal — clojure.string not implemented" }
    atoms-test:                 { status: pass }
    loop-recur-test:            { status: pass }
    for-test:                   { status: pass }
    cond-test:                  { status: pass }
    condp-test:                 { status: pass }
    case-test:                  { status: pass }
    comment-test:               { status: pass }
    declare-test:               { status: pass }
    defonce-test:               { status: pass }
    threading-test:             { status: pass }
    ifs-and-whens-test:         { status: pass }
    trampoline-test:            { status: pass }
    try-catch-test:             { status: pass }
    variable-can-shadow-test:   { status: pass }
    delay-and-defn-private-test: { status: pass }
    self-ref-test:              { status: pass }
    regex-test:                 { status: pass }
    some-threading-test:        { status: pass, note: "uses str instead of clojure.string/lower-case" }
    macroexpand-test:           { status: pass }
    while-test:                 { status: pass }
    collections-test:           { status: pass }
    higher-order-fns-test:      { status: pass }
    partition-group-test:       { status: pass }
    distinct-frequencies-test:  { status: pass }
    interleave-interpose-test:  { status: pass }
    function-combinators-test:  { status: pass }
    seq-slicing-test:           { status: pass }
    convenience-accessors-test: { status: pass }
    pred-fn-utils-test:         { status: pass }
    dotimes-test:               { status: pass }
    doseq-test:                 { status: pass }
    reduce-kv-test:             { status: pass }
    meta-test:                  { status: pass, note: "var :name metadata skipped; def moved outside deftest" }
    namespace-ops-test:         { status: pass }
    gensym-test:                { status: pass, note: "uses subs workaround (no clojure.string/starts-with?)" }
    eval-read-string-test:      { status: pass }
    macroexpand-detail-test:    { status: pass }
    basic-predicates-test:      { status: pass }
    memoize-test:               { status: pass }
    format-test:                { status: pass }
    compare-and-set-test:       { status: pass }
    hash-identity-test:         { status: pass }
    collection-ops-test:        { status: pass }
    subvec-test:                { status: pass }
    collection-constructors-test: { status: pass }
    reduced-test:               { status: pass }
    lazy-seq-test:              { status: pass }
    ex-info-test:               { status: pass }
    multimethod-test:           { status: pass }
    type-predicates-test:       { status: pass }
    bitwise-test:               { status: pass }
    sort-test:                  { status: pass }
    merge-test:                 { status: pass }
    type-coercion-test:         { status: pass }

  # Missing features (remaining after T13.1)
  missing_features:
    tier2_core_clj:
      - "clojure.string namespace (upper-case, lower-case, trim, includes?, split, join, starts-with?)"
      - "{:keys [:a]} — keyword in :keys destructuring vector"
    behavioral:
      - "var :name metadata — (meta #'x) :name not populated"
  # Resolved by T13.2:
  # - named fn self-reference (identity preserved via callee_fn_val)
  # - fn as param name shadows special form (local check before special_forms)
  # Resolved by T13.1:
  # - list? (now implemented)
  # - int? (now implemented)
  # - reduce/2 (2-arity reduce)
  # - set-as-function
  # - deref on delay
  # - (into {} [[:a 1]]) — conj map with vector pairs

# ==============================================================================
# Clojure JVM Equivalent Tests
# Source: test/upstream/clojure/test_clojure/*.clj
# Based on Clojure JVM test suite (test/clojure/test_clojure/)
# Java-dependent tests excluded; behavioral differences documented
# Added: 2026-02-03 (T14.11)
# ==============================================================================

clojure_test_clojure:
  summary:
    total: 116          # total deftests across all files
    active: 116         # running deftests
    pass: 116           # all assertions pass
    fail: 0             # assertion failures
    skip: 0             # none
    assertions: 758     # total is-assertions in active tests
    files: 8            # test files ported

  # --------------------------------------------------------------------------
  # macros.clj - Threading macro tests
  # --------------------------------------------------------------------------
  macros:
    file: test/clojure/macros.clj
    tests: 10
    assertions: 27
    status: pass
    excluded_features: []
    tests_detail:
      ->test:               { status: pass }
      ->>test:              { status: pass }
      ->metadata-test:      { status: pass }
      ->>metadata-test:     { status: pass }
      some->test:           { status: pass }
      some->>test:          { status: pass }
      cond->test:           { status: pass }
      cond->>test:          { status: pass }
      as->test:             { status: pass }
      threading-loop-recur: { status: pass }

  # --------------------------------------------------------------------------
  # for.clj - List comprehension tests
  # --------------------------------------------------------------------------
  for:
    file: test/upstream/clojure/test_clojure/for.clj
    tests: 4
    assertions: 12
    status: pass
    excluded_features:
      - "F25: :while modifier not implemented"
      - "F26: :let + :when combination fails"
    tests_detail:
      for-when-test:       { status: pass }
      for-nesting-test:    { status: pass }
      for-let-test:        { status: pass }
      for-basic-test:      { status: pass }

  # --------------------------------------------------------------------------
  # control.clj - Control flow tests
  # --------------------------------------------------------------------------
  control:
    file: test/upstream/clojure/test_clojure/control.clj
    tests: 12
    assertions: 66
    status: pass
    excluded_features:
      - "F27: case multiple test values syntax"
      - "F28: case symbol matching"
      - "F29: empty list () truthy behavior"
      - "F30: if-let 2-arg (optional else)"
    tests_detail:
      test-do:        { status: pass }
      test-loop:      { status: pass }
      test-when:      { status: pass }
      test-when-not:  { status: pass }
      test-if-not:    { status: pass }
      test-when-let:  { status: pass }
      test-if-let:    { status: pass }
      test-cond:      { status: pass, note: "() truthy test excluded (F29)" }
      test-condp:     { status: pass }
      test-dotimes:   { status: pass }
      test-while:     { status: pass }
      test-case:      { status: pass, note: "symbol matching excluded (F28)" }

  # --------------------------------------------------------------------------
  # logic.clj - Boolean logic tests
  # --------------------------------------------------------------------------
  logic:
    file: test/upstream/clojure/test_clojure/logic.clj
    tests: 6
    assertions: 80
    status: pass
    excluded_features:
      - "F31: (and) returns true — ClojureWasm returns nil"
      - "F32: (reverse nil/[]) returns empty list — ClojureWasm returns nil"
    tests_detail:
      test-if:          { status: pass }
      test-nil-punning: { status: pass, note: "reverse/concat adjusted for ClojureWasm" }
      test-and:         { status: pass, note: "(and) test excluded (F31)" }
      test-or:          { status: pass }
      test-not:         { status: pass }
      test-some?:       { status: pass }

  # --------------------------------------------------------------------------
  # predicates.clj - Type predicate tests
  # --------------------------------------------------------------------------
  predicates:
    file: test/upstream/clojure/test_clojure/predicates.clj
    tests: 20
    assertions: 143
    status: pass
    excluded_features:
      - "F33: () type predicates — list?/coll?/seq? return false for ()"
      - "F34: seq returns proper seq type"
      - "F35: sequential? predicate not implemented"
      - "F36: associative? predicate not implemented"
      - "F37: ifn? predicate not implemented"
    tests_detail:
      test-nil?:      { status: pass }
      test-true?:     { status: pass }
      test-false?:    { status: pass }
      test-number?:   { status: pass }
      test-integer?:  { status: pass }
      test-float?:    { status: pass }
      test-symbol?:   { status: pass }
      test-keyword?:  { status: pass }
      test-string?:   { status: pass }
      test-char?:     { status: pass }
      test-list?:     { status: pass, note: "() test excluded (F33)" }
      test-vector?:   { status: pass }
      test-map?:      { status: pass }
      test-set?:      { status: pass }
      test-coll?:     { status: pass, note: "() test excluded (F33)" }
      test-seq?:      { status: pass, note: "() test excluded (F33)" }
      test-fn?:       { status: pass }
      test-empty?:    { status: pass }
      test-pos-neg-zero: { status: pass }
      test-even-odd:  { status: pass }

  # --------------------------------------------------------------------------
  # atoms.clj - Atom tests
  # --------------------------------------------------------------------------
  atoms:
    file: test/upstream/clojure/test_clojure/atoms.clj
    tests: 14
    assertions: 39
    status: pass
    excluded_features:
      - "F38: swap-vals! not implemented"
      - "F39: reset-vals! not implemented"
    tests_detail:
      test-atom-creation:           { status: pass }
      test-atom-with-collections:   { status: pass }
      test-deref:                   { status: pass }
      test-swap!-basic:             { status: pass }
      test-swap!-returns-new-value: { status: pass }
      test-swap!-with-args:         { status: pass }
      test-swap!-with-collections:  { status: pass }
      test-reset!-basic:            { status: pass }
      test-reset!-returns-new-value: { status: pass }
      test-compare-and-set!-success: { status: pass }
      test-compare-and-set!-failure: { status: pass }
      test-compare-and-set!-with-nil: { status: pass }
      test-atom-nested-operations:  { status: pass }
      test-atom-update-with-current-value: { status: pass }

  # --------------------------------------------------------------------------
  # sequences.clj - Sequence operation tests
  # --------------------------------------------------------------------------
  sequences:
    file: test/upstream/clojure/test_clojure/sequences.clj
    tests: 33
    assertions: 188
    status: pass
    excluded_features:
      - "F40: first/rest on set"
      - "F41: first/rest on string"
      - "F43: ffirst function"
      - "F44: nnext function"
      - "F45: interleave 0-1 args"
      - "F46: drop-last function"
      - "F47: split-at / split-with"
      - "F48: (range) infinite sequence"
      - "F49: partition with step arg"
      - "F50: reductions function"
      - "F51: shuffle function"
    tests_detail:
      test-first-basic:   { status: pass }
      test-rest-basic:    { status: pass }
      test-next-basic:    { status: pass }
      test-cons-basic:    { status: pass }
      test-fnext:         { status: pass }
      test-nfirst:        { status: pass }
      test-last:          { status: pass }
      test-nth-basic:     { status: pass }
      test-distinct:      { status: pass }
      test-interpose:     { status: pass }
      test-interleave:    { status: pass }
      test-zipmap:        { status: pass }
      test-concat:        { status: pass }
      test-cycle:         { status: pass }
      test-iterate:       { status: pass }
      test-reverse:       { status: pass }
      test-take:          { status: pass }
      test-drop:          { status: pass }
      test-take-while:    { status: pass }
      test-drop-while:    { status: pass }
      test-butlast:       { status: pass }
      test-repeat:        { status: pass }
      test-range:         { status: pass }
      test-partition:     { status: pass }
      test-partition-all: { status: pass }
      test-every?:        { status: pass }
      test-not-every?:    { status: pass }
      test-not-any?:      { status: pass }
      test-some:          { status: pass }
      test-flatten:       { status: pass }
      test-group-by:      { status: pass }
      test-partition-by:  { status: pass }
      test-frequencies:   { status: pass }

  # --------------------------------------------------------------------------
  # data_structures.clj - Data structure tests
  # --------------------------------------------------------------------------
  data_structures:
    file: test/upstream/clojure/test_clojure/data_structures.clj
    tests: 17
    assertions: 203
    status: pass
    excluded_features:
      - "F58: nested map destructuring"
    tests_detail:
      test-equality:   { status: pass }
      test-count:      { status: pass }
      test-conj:       { status: pass }
      test-peek:       { status: pass }
      test-pop:        { status: pass }
      test-list:       { status: pass }
      test-find:       { status: pass }
      test-contains?:  { status: pass }
      test-keys:       { status: pass }
      test-vals:       { status: pass }
      test-key:        { status: pass }
      test-val:        { status: pass }
      test-get:        { status: pass }
      test-hash-set:   { status: pass }
      test-set:        { status: pass }
      test-disj:       { status: pass }
      test-assoc:      { status: pass }

  # --------------------------------------------------------------------------
  # Feature exclusions summary (referenced by F## in checklist.md)
  # --------------------------------------------------------------------------
  excluded_features_summary:
    for_macro:
      - "F25: :while modifier"
      - "F26: :let + :when combination"
    control_flow:
      - "F27: case multiple test values"
      - "F28: case symbol matching"
      - "F29: empty list () is truthy in JVM"
      - "F30: if-let optional else clause"
    logic:
      - "F31: (and) returns true"
      - "F32: (reverse nil/[]) returns empty list"
    predicates:
      - "F33: () type predicates"
      - "F34: seq returns proper seq type"
      - "F35: sequential? predicate"
      - "F36: associative? predicate"
      - "F37: ifn? predicate"
    atoms:
      - "F38: swap-vals!"
      - "F39: reset-vals!"
    sequences:
      - "F40: first/rest on set"
      - "F41: first/rest on string"
      - "F43: ffirst"
      - "F44: nnext"
      - "F45: interleave 0-1 args"
      - "F46: drop-last"
      - "F47: split-at / split-with"
      - "F48: infinite range"
      - "F49: partition with step"
      - "F50: reductions"
      - "F51: shuffle"
    data_structures:
      - "F58: nested map destructuring"
