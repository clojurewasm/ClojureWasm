# ClojureWasm Var Implementation Status
# Generated from Clojure JVM reference implementation
#
# Field definitions:
#   type: Classification in upstream Clojure
#     special-form | function | macro | dynamic-var | var
#   status: Implementation state
#     todo | wip | partial | done | skip
#   note: (optional) Developer notes
#     Deviations from upstream, implementation constraints, VM optimizations, etc.

vars:
  clojure_core:
    ".": {type: special-form, status: skip, note: "JVM interop"}
    "case*": {type: special-form, status: skip, note: 'internal special form, case macro handled'}
    catch: {type: special-form, status: done, note: special form (part of try)}
    def: {type: special-form, status: done, note: special form}
    "deftype*": {type: special-form, status: skip, note: "JVM type system"}
    do: {type: special-form, status: done, note: special form}
    finally: {type: special-form, status: done, note: "special form (part of try)"}
    "fn*": {type: special-form, status: done, note: special form}
    if: {type: special-form, status: done, note: special form}
    "import*": {type: special-form, status: skip, note: "JVM interop"}
    "let*": {type: special-form, status: done, note: special form}
    "letfn*": {type: special-form, status: skip, note: internal special form}
    "loop*": {type: special-form, status: done, note: special form}
    "monitor-enter": {type: special-form, status: skip, note: "JVM concurrency"}
    "monitor-exit": {type: special-form, status: skip, note: "JVM concurrency"}
    new: {type: special-form, status: skip, note: "JVM interop"}
    quote: {type: special-form, status: done, note: special form}
    recur: {type: special-form, status: done, note: special form}
    "reify*": {type: special-form, status: skip, note: "JVM type system"}
    "set!": {type: special-form, status: partial, note: "UPSTREAM-DIFF: metadata registered but not in analyzer dispatch; needs F85 binding"}
    throw: {type: special-form, status: done, note: special form}
    try: {type: special-form, status: done, note: special form}
    var: {type: special-form, status: done, note: special form}
    "*": {type: function, status: done, note: "VM intrinsic opcode"}
    "*'": {type: function, status: done, note: "Zig builtin (upstream uses Math.multiplyExact)"}
    "*1": {type: dynamic-var, status: done, note: "REPL history var"}
    "*2": {type: dynamic-var, status: done, note: "REPL history var"}
    "*3": {type: dynamic-var, status: done, note: "REPL history var"}
    "*agent*": {type: var, status: skip, note: JVM interop}
    "*allow-unresolved-vars*": {type: var, status: skip, note: JVM interop}
    "*assert*": {type: var, status: done, note: "dynamic var"}
    "*clojure-version*": {type: dynamic-var, status: done, note: "dynamic var"}
    "*command-line-args*": {type: var, status: done}
    "*compile-files*": {type: var, status: done, note: JVM interop}
    "*compile-path*": {type: var, status: skip, note: JVM interop}
    "*compiler-options*": {type: var, status: done, note: 'dynamic var, synced with env.current_ns'}
    "*data-readers*": {type: dynamic-var, status: done}
    "*default-data-reader-fn*": {type: dynamic-var, status: done}
    "*e": {type: dynamic-var, status: done, note: "stub (nil default)"}
    "*err*": {type: var, status: done, note: "stub (nil default)"}
    "*file*": {type: var, status: done}
    "*flush-on-newline*": {type: var, status: done}
    "*fn-loader*": {type: var, status: skip, note: JVM interop}
    "*in*": {type: var, status: done, note: "stub (nil default)"}
    "*math-context*": {type: var, status: skip, note: JVM interop}
    "*ns*": {type: var, status: done, note: 'dynamic var, synced with env.current_ns'}
    "*out*": {type: var, status: done, note: "stub (nil default)"}
    "*print-dup*": {type: var, status: done, note: "stub (false default)"}
    "*print-length*": {type: dynamic-var, status: done}
    "*print-level*": {type: dynamic-var, status: done}
    "*print-meta*": {type: var, status: done}
    "*print-namespace-maps*": {type: dynamic-var, status: done}
    "*print-readably*": {type: var, status: done}
    "*read-eval*": {type: var, status: done}
    "*reader-resolver*": {type: var, status: skip, note: JVM interop}
    "*repl*": {type: dynamic-var, status: done}
    "*source-path*": {type: var, status: done}
    "*suppress-read*": {type: var, status: skip, note: JVM interop}
    "*unchecked-math*": {type: var, status: done}
    "*use-context-classloader*": {type: var, status: skip, note: JVM interop}
    "*verbose-defrecords*": {type: dynamic-var, status: done}
    "*warn-on-reflection*": {type: var, status: done, note: "stub dynamic var (no reflection in Zig)"}
    "+": {type: function, status: done, note: "VM intrinsic opcode"}
    "+'": {type: function, status: done, note: "Zig builtin (upstream uses Math.addExact)"}
    "-": {type: function, status: done, note: "VM intrinsic opcode"}
    "-'": {type: function, status: done, note: "Zig builtin (upstream uses Math.subtractExact)"}
    "->": {type: macro, status: done, note: "macro in core.clj"}
    "->>": {type: macro, status: done, note: "macro in core.clj"}
    "->ArrayChunk": {type: function, status: skip, note: "JVM interop"}
    "->Eduction": {type: function, status: skip, note: "JVM interop"}
    "->Vec": {type: function, status: skip, note: "JVM interop"}
    "->VecNode": {type: function, status: skip, note: "JVM interop"}
    "->VecSeq": {type: function, status: skip, note: "JVM interop"}
    "-cache-protocol-fn": {type: function, status: skip, note: JVM interop}
    "-reset-methods": {type: function, status: skip, note: JVM interop}
    "..": {type: macro, status: skip, note: JVM interop}
    "/": {type: function, status: done, note: "always returns float (D12); VM intrinsic opcode"}
    "<": {type: function, status: done, note: "VM intrinsic opcode"}
    "<=": {type: function, status: done, note: "VM intrinsic opcode"}
    "=": {type: function, status: done, note: "VM intrinsic opcode"}
    "==": {type: function, status: done, note: "builtin (upstream is pure clj via Numbers.equiv)"}
    ">": {type: function, status: done, note: "VM intrinsic opcode"}
    ">=": {type: function, status: done, note: "VM intrinsic opcode"}
    "EMPTY-NODE": {type: var, status: skip, note: JVM interop}
    Inst: {type: var, status: done, note: 'dynamic var, synced with env.current_ns'}
    "NaN?": {type: function, status: done, note: "core.clj (upstream uses Double/isNaN)"}
    "PrintWriter-on": {type: function, status: skip, note: JVM interop}
    "StackTraceElement->vec": {type: function, status: skip, note: "JVM interop"}
    "Throwable->map": {type: function, status: skip, note: "JVM interop"}
    abs: {type: function, status: done, note: "Zig builtin"}
    accessor: {type: function, status: skip, note: deprecated struct system}
    aclone: {type: function, status: skip, note: JVM interop}
    "add-classpath": {type: function, status: skip, note: JVM interop}
    "add-tap": {type: function, status: done}
    "add-watch": {type: function, status: done}
    agent: {type: function, status: skip, note: JVM interop}
    "agent-error": {type: function, status: skip, note: JVM interop}
    "agent-errors": {type: function, status: skip, note: JVM interop}
    aget: {type: function, status: skip, note: JVM interop}
    alength: {type: function, status: skip, note: JVM interop}
    alias: {type: function, status: done, note: builtin (upstream is pure clj)}
    "all-ns": {type: function, status: done, note: "dynamic var, synced with env.current_ns"}
    alter: {type: function, status: skip, note: JVM interop}
    "alter-meta!": {type: function, status: done, note: "Zig builtin: mutates atom metadata"}
    "alter-var-root": {type: function, status: done, note: builtin (upstream is pure clj)}
    amap: {type: macro, status: skip, note: JVM interop}
    ancestors: {type: function, status: done, note: core.clj hierarchy-aware}
    and: {type: macro, status: done, note: "macro in core.clj"}
    "any?": {type: function, status: done, note: "core.clj always true"}
    apply: {type: function, status: done, note: "Zig builtin"}
    areduce: {type: macro, status: skip, note: JVM interop}
    "array-map": {type: function, status: done, note: "Zig builtin"}
    "as->": {type: macro, status: done, note: "macro in core.clj"}
    aset: {type: function, status: skip, note: JVM interop}
    "aset-boolean": {type: function, status: skip, note: JVM interop}
    "aset-byte": {type: function, status: skip, note: JVM interop}
    "aset-char": {type: function, status: skip, note: JVM interop}
    "aset-double": {type: function, status: skip, note: JVM interop}
    "aset-float": {type: function, status: skip, note: JVM interop}
    "aset-int": {type: function, status: skip, note: JVM interop}
    "aset-long": {type: function, status: skip, note: JVM interop}
    "aset-short": {type: function, status: skip, note: JVM interop}
    assert: {type: macro, status: done, note: 'CLJW: str throw instead of AssertionError (JVM class)'}
    assoc: {type: function, status: done, note: "Zig builtin"}
    "assoc!": {type: function, status: done}
    "assoc-in": {type: function, status: done, note: "core.clj (upstream is pure clj)"}
    "associative?": {type: function, status: done, note: "Zig builtin"}
    atom: {type: function, status: done, note: "Zig builtin"}
    await: {type: function, status: skip, note: JVM interop}
    "await-for": {type: function, status: skip, note: JVM interop}
    await1: {type: function, status: skip, note: JVM interop}
    bases: {type: function, status: skip, note: JVM interop}
    bean: {type: function, status: skip, note: JVM interop}
    bigdec: {type: function, status: skip, note: no BigDecimal type}
    bigint: {type: function, status: skip, note: no BigInteger type}
    biginteger: {type: function, status: skip, note: no BigInteger type}
    binding: {type: macro, status: done}
    "bit-and": {type: function, status: done, note: "Zig builtin"}
    "bit-and-not": {type: function, status: done, note: builtin (upstream is pure clj)}
    "bit-clear": {type: function, status: done, note: "Zig builtin (upstream is pure clj)"}
    "bit-flip": {type: function, status: done, note: "Zig builtin (upstream is pure clj)"}
    "bit-not": {type: function, status: done, note: "Zig builtin"}
    "bit-or": {type: function, status: done, note: "Zig builtin"}
    "bit-set": {type: function, status: done, note: "Zig builtin (upstream is pure clj)"}
    "bit-shift-left": {type: function, status: done, note: "Zig builtin"}
    "bit-shift-right": {type: function, status: done, note: "Zig builtin"}
    "bit-test": {type: function, status: done, note: "Zig builtin (upstream is pure clj)"}
    "bit-xor": {type: function, status: done, note: "Zig builtin"}
    boolean: {type: function, status: done, note: "core.clj (if x true false)"}
    "boolean-array": {type: function, status: skip, note: JVM interop}
    "boolean?": {type: function, status: done, note: "Zig builtin"}
    booleans: {type: function, status: done, note: 'dynamic var, synced with env.current_ns'}
    "bound-fn": {type: macro, status: skip, note: JVM interop}
    "bound-fn*": {type: function, status: skip, note: JVM interop}
    "bound?": {type: function, status: done, note: 'Takes var_ref or symbol (variadic)'}
    "bounded-count": {type: function, status: done, note: builtin (upstream is pure clj)}
    butlast: {type: function, status: done, note: "core.clj loop"}
    byte: {type: function, status: done, note: builtin (upstream is pure clj)}
    "byte-array": {type: function, status: skip, note: JVM interop}
    bytes: {type: function, status: skip, note: JVM interop}
    "bytes?": {type: function, status: skip, note: "no byte array type"}
    case: {type: macro, status: done, note: "Zig builtin compiler support"}
    cast: {type: function, status: done, note: identity (no JVM type system)}
    cat: {type: function, status: done, note: "core.clj (upstream is pure clj)"}
    char: {type: function, status: done, note: builtin (upstream is pure clj)}
    "char-array": {type: function, status: skip, note: JVM interop}
    "char-escape-string": {type: var, status: done, note: core.clj (from core_print.clj)}
    "char-name-string": {type: var, status: done, note: core.clj (from core_print.clj)}
    "char?": {type: function, status: done, note: "Zig builtin"}
    chars: {type: function, status: skip, note: JVM interop}
    chunk: {type: function, status: done, note: builtin}
    "chunk-append": {type: function, status: done, note: builtin}
    "chunk-buffer": {type: function, status: done, note: builtin}
    "chunk-cons": {type: function, status: done, note: 'builtin (upstream uses Java constructor)'}
    "chunk-first": {type: function, status: done, note: builtin}
    "chunk-next": {type: function, status: done, note: builtin}
    "chunk-rest": {type: function, status: done, note: builtin}
    "chunked-seq?": {type: function, status: done, note: "builtin"}
    class: {type: function, status: done, note: "Zig builtin alias of type"}
    "class?": {type: function, status: skip, note: "no Java class system"}
    "clear-agent-errors": {type: function, status: skip, note: JVM interop}
    "clojure-version": {type: function, status: done, note: "core.clj (upstream is pure clj)"}
    "coll?": {type: function, status: done, note: "Zig builtin"}
    comment: {type: macro, status: done, note: "macro in core.clj"}
    commute: {type: function, status: skip, note: JVM interop}
    comp: {type: function, status: done, note: "core.clj (upstream is pure clj)"}
    comparator: {type: function, status: done, note: "core.clj (upstream is pure clj)"}
    compare: {type: function, status: done, note: "Zig builtin"}
    "compare-and-set!": {type: function, status: done, note: "Zig builtin"}
    compile: {type: function, status: skip, note: JVM interop}
    complement: {type: function, status: done, note: "core.clj (upstream is pure clj)"}
    completing: {type: function, status: done, note: "core.clj (upstream is pure clj)"}
    concat: {type: function, status: done, note: "Zig builtin"}
    cond: {type: macro, status: done, note: 'CLJW: error on odd forms caught at analysis time (not runtime)'}
    "cond->": {type: macro, status: done, note: "macro in core.clj"}
    "cond->>": {type: macro, status: done, note: "macro in core.clj"}
    condp: {type: macro, status: done, note: "UPSTREAM-DIFF (minor): uses manual destructuring instead of split-at (bootstrap order)"}
    conj: {type: function, status: done, note: "Zig builtin"}
    "conj!": {type: function, status: done}
    cons: {type: function, status: done, note: "dynamic var, synced with env.current_ns"}
    constantly: {type: function, status: done, note: "dynamic var, synced with env.current_ns"}
    "construct-proxy": {type: function, status: done, note: 'dynamic var, synced with env.current_ns'}
    "contains?": {type: function, status: done, note: "dynamic var, synced with env.current_ns"}
    count: {type: function, status: done, note: "Zig builtin"}
    "counted?": {type: function, status: done, note: builtin (upstream is pure clj)}
    "create-ns": {type: function, status: done, note: "dynamic var, synced with env.current_ns"}
    "create-struct": {type: function, status: skip, note: deprecated struct system}
    cycle: {type: function, status: done, note: "core.clj (upstream is pure clj)"}
    dec: {type: function, status: done, note: "core.clj (upstream is pure clj)"}
    "dec'": {type: function, status: done, note: "core.clj (upstream is pure clj)"}
    "decimal?": {type: function, status: done, note: builtin (upstream is pure clj)}
    declare: {type: macro, status: done, note: "core.clj (do (def name) ...)"}
    dedupe: {type: function, status: done}
    "default-data-readers": {type: var, status: done}
    definline: {type: macro, status: skip, note: JVM optimization}
    definterface: {type: macro, status: skip, note: JVM interop}
    defmacro: {type: macro, status: done, note: "special form in this impl; analyzer special form in CW"}
    defmethod: {type: macro, status: done, note: "analyzer special form in CW"}
    defmulti: {type: macro, status: done, note: "analyzer special form in CW"}
    defn: {type: macro, status: done, note: 'UPSTREAM-DIFF (permanent): simplified, no docstring/metadata/pre-post/inline (upstream is heavy Java interop)'}
    "defn-": {type: macro, status: done, note: "macro in core.clj"}
    defonce: {type: macro, status: done, note: "Macro in core.clj using bound?"}
    defprotocol: {type: macro, status: done, note: "analyzer special form in CW"}
    defrecord: {type: macro, status: done, note: "analyzer special form in CW"}
    defstruct: {type: macro, status: skip, note: deprecated struct system}
    deftype: {type: macro, status: skip, note: needs full type/protocol infrastructure}
    delay: {type: macro, status: done, note: "builtin Delay type (D66)"}
    "delay?": {type: function, status: done, note: "builtin __delay? predicate"}
    deliver: {type: function, status: done, note: "UPSTREAM-DIFF (permanent): atom-based, no blocking deref (no Java concurrency)"}
    denominator: {type: function, status: skip, note: no Ratio type}
    deref: {type: function, status: done, note: "Zig builtin"}
    derive: {type: function, status: done, note: core.clj hierarchy-aware}
    descendants: {type: function, status: done, note: core.clj hierarchy-aware}
    destructure: {type: function, status: skip, note: compiler handles destructuring directly}
    disj: {type: function, status: done, note: "Zig builtin"}
    "disj!": {type: function, status: done}
    dissoc: {type: function, status: done, note: "Zig builtin"}
    "dissoc!": {type: function, status: done}
    distinct: {type: function, status: done, note: "core.clj (upstream is pure clj)"}
    "distinct?": {type: function, status: done, note: "Zig builtin"}
    doall: {type: function, status: done, note: "core.clj dorun+return"}
    dorun: {type: function, status: done, note: "core.clj loop over seq"}
    doseq: {type: macro, status: done, note: "UPSTREAM-DIFF (minor): uses next/next instead of nnext (bootstrap order); nth instead of .nth"}
    dosync: {type: macro, status: skip, note: JVM interop}
    dotimes: {type: macro, status: done, note: 'UPSTREAM-DIFF (minor): inline validation instead of assert-args (bootstrap order)'}
    doto: {type: macro, status: done, note: "macro in core.clj"}
    double: {type: function, status: done, note: builtin (upstream is pure clj)}
    "double-array": {type: function, status: skip, note: JVM interop}
    "double?": {type: function, status: done, note: "Zig builtin"}
    doubles: {type: function, status: skip, note: "JVM interop (double-array)"}
    drop: {type: function, status: done, note: "core.clj (upstream is pure clj)"}
    "drop-last": {type: function, status: done, note: "core.clj (upstream is pure clj)"}
    "drop-while": {type: function, status: done, note: "core.clj loop+pred"}
    eduction: {type: function, status: done, note: needs IReduceInit protocol, notes: 'UPSTREAM-DIFF: eager sequence wrapper (no deftype)'}
    empty: {type: function, status: done, note: "Zig builtin"}
    "empty?": {type: function, status: done, note: "Zig builtin"}
    ensure: {type: function, status: done, note: 'dynamic var, synced with env.current_ns'}
    "ensure-reduced": {type: function, status: done, note: "dynamic var, synced with env.current_ns"}
    "enumeration-seq": {type: function, status: skip, note: JVM interop}
    "error-handler": {type: function, status: skip, note: JVM interop}
    "error-mode": {type: function, status: skip, note: JVM interop}
    eval: {type: function, status: done, note: "Zig builtin"}
    "even?": {type: function, status: done, note: "Zig builtin (upstream is pure clj)"}
    "every-pred": {type: function, status: done, note: "core.clj and-based combinator"}
    "every?": {type: function, status: done, note: "core.clj (upstream is pure clj)"}
    "ex-cause": {type: function, status: done}
    "ex-data": {type: function, status: done, note: "Zig builtin"}
    "ex-info": {type: function, status: done, note: "Zig builtin"}
    "ex-message": {type: function, status: done, note: "Zig builtin"}
    extend: {type: function, status: skip, note: JVM interop}
    "extend-protocol": {type: macro, status: skip, note: JVM interop}
    "extend-type": {type: macro, status: done, note: "analyzer special form in CW"}
    extenders: {type: function, status: skip, note: JVM interop}
    "extends?": {type: function, status: skip, note: JVM interop}
    "false?": {type: function, status: done, note: "core.clj (= x false)"}
    ffirst: {type: function, status: done, note: "core.clj (upstream is pure clj)"}
    "file-seq": {type: function, status: done}
    filter: {type: function, status: done, note: "eager (no lazy seq)"}
    filterv: {type: function, status: done, note: "core.clj (vec (filter pred coll))"}
    find: {type: function, status: done, note: "Zig builtin"}
    "find-keyword": {type: function, status: done, note: 'F80: needs keyword intern table'}
    "find-ns": {type: function, status: done, note: "dynamic var, synced with env.current_ns"}
    "find-protocol-impl": {type: function, status: skip, note: JVM interop}
    "find-protocol-method": {type: function, status: skip, note: JVM interop}
    "find-var": {type: function, status: done}
    first: {type: function, status: done, note: "Zig builtin"}
    flatten: {type: function, status: done, note: "core.clj (upstream is pure clj)"}
    float: {type: function, status: done, note: builtin (upstream is pure clj)}
    "float-array": {type: function, status: skip, note: JVM interop}
    "float?": {type: function, status: done, note: "Zig builtin"}
    floats: {type: function, status: skip, note: JVM interop}
    flush: {type: function, status: done, note: "Zig builtin"}
    fn: {type: special-form, status: done, note: special form (analyzes as fn*)}
    "fn?": {type: function, status: done, note: special form}
    fnext: {type: function, status: done, note: "special form"}
    fnil: {type: function, status: done, note: "special form"}
    for: {type: macro, status: done, note: "analyzer special form in CW"}
    force: {type: function, status: done, note: "core.clj delay-aware evaluation"}
    format: {type: function, status: done, note: "Zig builtin"}
    frequencies: {type: function, status: done, note: "core.clj (upstream is pure clj)"}
    future: {type: macro, status: skip, note: needs thread pool}
    "future-call": {type: function, status: skip, note: needs thread pool}
    "future-cancel": {type: function, status: skip, note: needs thread pool}
    "future-cancelled?": {type: function, status: skip, note: needs thread pool}
    "future-done?": {type: function, status: skip, note: needs thread pool}
    "future?": {type: function, status: skip, note: "no future type"}
    "gen-class": {type: macro, status: skip, note: JVM interop}
    "gen-interface": {type: macro, status: skip, note: JVM interop}
    gensym: {type: function, status: done, note: "dynamic var, synced with env.current_ns"}
    get: {type: function, status: done, note: "Zig builtin"}
    "get-in": {type: function, status: done, note: "core.clj (upstream is pure clj)"}
    "get-method": {type: function, status: done, note: builtin (upstream is pure clj)}
    "get-proxy-class": {type: function, status: skip, note: JVM interop}
    "get-thread-bindings": {type: function, status: skip, note: JVM interop}
    "get-validator": {type: function, status: done}
    "group-by": {type: function, status: done, note: "core.clj (upstream is pure clj)"}
    "halt-when": {type: function, status: done}
    hash: {type: function, status: done, note: "Zig builtin"}
    "hash-combine": {type: function, status: done}
    "hash-map": {type: function, status: done, note: "Zig builtin"}
    "hash-ordered-coll": {type: function, status: done}
    "hash-set": {type: function, status: done, note: "Zig builtin"}
    "hash-unordered-coll": {type: function, status: done}
    "ident?": {type: function, status: done, note: "core.clj (upstream is pure clj)"}
    "identical?": {type: function, status: done, note: "Zig builtin"}
    identity: {type: function, status: done, note: "core.clj (upstream is pure clj)"}
    "if-let": {type: macro, status: done, note: 'CLJW: uses (first (next ...)) instead of second (bootstrap order)'}
    "if-not": {type: macro, status: done, note: "macro in core.clj"}
    "if-some": {type: macro, status: done}
    "ifn?": {type: function, status: done, note: "Zig builtin"}
    import: {type: macro, status: skip, note: JVM interop}
    "in-ns": {type: var, status: done, note: 'dynamic var, synced with env.current_ns'}
    inc: {type: function, status: done, note: "core.clj (upstream is pure clj)"}
    "inc'": {type: function, status: done, note: "core.clj (upstream is pure clj)"}
    "indexed?": {type: function, status: done, note: builtin (upstream is pure clj)}
    "infinite?": {type: function, status: done, note: "core.clj (upstream is pure clj)"}
    "init-proxy": {type: function, status: skip, note: JVM interop}
    "inst-ms": {type: function, status: done, note: 'dynamic var, synced with env.current_ns'}
    "inst-ms*": {type: function, status: done, note: 'dynamic var, synced with env.current_ns'}
    "inst?": {type: function, status: done, note: 'dynamic var, synced with env.current_ns'}
    "instance?": {type: function, status: done, note: "dynamic var, synced with env.current_ns"}
    int: {type: function, status: done, note: builtin (upstream is pure clj)}
    "int-array": {type: function, status: skip, note: JVM interop}
    "int?": {type: function, status: done, note: "Zig builtin"}
    "integer?": {type: function, status: done, note: "Zig builtin"}
    interleave: {type: function, status: done, note: "core.clj (upstream is pure clj)"}
    intern: {type: function, status: done}
    interpose: {type: function, status: done, note: "core.clj (upstream is pure clj)"}
    into: {type: function, status: done, note: "portable to clj"}
    "into-array": {type: function, status: skip, note: JVM interop}
    ints: {type: function, status: skip, note: JVM interop}
    "io!": {type: macro, status: skip, note: "JVM interop"}
    "isa?": {type: function, status: done, note: "core.clj hierarchy-aware"}
    iterate: {type: function, status: done, note: "core.clj (upstream is pure clj)"}
    iteration: {type: function, status: done, note: needs lazy stateful iterator, notes: 'UPSTREAM-DIFF: lazy-seq wrapper (no reify/IReduceInit)'}
    "iterator-seq": {type: function, status: skip, note: JVM interop}
    juxt: {type: function, status: done, note: "core.clj (upstream is pure clj)"}
    keep: {type: function, status: done, note: "core.clj (upstream is pure clj)"}
    "keep-indexed": {type: function, status: done, note: "core.clj (upstream is pure clj)"}
    key: {type: function, status: done, note: "Zig builtin"}
    keys: {type: function, status: done, note: "Zig builtin"}
    keyword: {type: function, status: done, note: "Zig builtin"}
    "keyword?": {type: function, status: done, note: "Zig builtin"}
    last: {type: function, status: done, note: "core.clj loop to end"}
    "lazy-cat": {type: macro, status: done, note: "macro in core.clj"}
    "lazy-seq": {type: macro, status: done, note: "analyzer special form in CW"}
    let: {type: special-form, status: done, note: special form (analyzes as let*)}
    letfn: {type: special-form, status: skip, note: internal special form}
    "line-seq": {type: function, status: skip, note: needs BufferedReader type}
    list: {type: function, status: done, note: "Zig builtin"}
    "list*": {type: function, status: done, note: "Zig builtin"}
    "list?": {type: function, status: done, note: "Zig builtin"}
    load: {type: function, status: done}
    "load-file": {type: var, status: done, note: 'Zig builtin, reads + evals file'}
    "load-reader": {type: function, status: skip, note: needs Reader type}
    "load-string": {type: function, status: done}
    "loaded-libs": {type: function, status: done}
    locking: {type: macro, status: done, note: "UPSTREAM-DIFF (permanent): single-threaded no-op (no Java monitors)"}
    long: {type: function, status: done, note: builtin (upstream is pure clj)}
    "long-array": {type: function, status: skip, note: JVM interop}
    longs: {type: function, status: skip, note: JVM interop}
    loop: {type: special-form, status: done, note: special form (analyzes as loop*)}
    macroexpand: {type: function, status: done, note: "Zig builtin"}
    "macroexpand-1": {type: function, status: done, note: "Zig builtin"}
    "make-array": {type: function, status: skip, note: JVM interop}
    "make-hierarchy": {type: function, status: done, note: "core.clj (upstream is pure clj)"}
    map: {type: function, status: done, note: "eager (no lazy seq)"}
    "map-entry?": {type: function, status: done}
    "map-indexed": {type: function, status: done, note: "core.clj (upstream is pure clj)"}
    "map?": {type: function, status: done, note: "Zig builtin"}
    mapcat: {type: function, status: done, note: "core.clj (upstream is pure clj)"}
    mapv: {type: function, status: done, note: "core.clj with transient"}
    max: {type: function, status: done, note: "Zig builtin"}
    "max-key": {type: function, status: done, note: "core.clj (upstream is pure clj)"}
    memfn: {type: macro, status: skip, note: JVM interop}
    memoize: {type: function, status: done, note: "core.clj (upstream is pure clj)"}
    merge: {type: function, status: done, note: "Zig builtin"}
    "merge-with": {type: function, status: done, note: "Zig builtin"}
    meta: {type: function, status: done, note: 'Zig builtin: returns metadata map from collections, fn, atom'}
    "method-sig": {type: function, status: skip, note: JVM interop}
    methods: {type: function, status: done, note: builtin (upstream is pure clj)}
    min: {type: function, status: done, note: "Zig builtin"}
    "min-key": {type: function, status: done, note: "core.clj (upstream is pure clj)"}
    "mix-collection-hash": {type: function, status: done}
    mod: {type: function, status: done, note: "VM intrinsic opcode"}
    munge: {type: function, status: done}
    name: {type: function, status: done, note: "Zig builtin"}
    namespace: {type: function, status: done, note: "Zig builtin"}
    "namespace-munge": {type: function, status: done}
    "nat-int?": {type: function, status: done, note: "core.clj (upstream is pure clj)"}
    "neg-int?": {type: function, status: done, note: "Zig builtin"}
    "neg?": {type: function, status: done, note: "Zig builtin"}
    newline: {type: function, status: done, note: "Zig builtin"}
    next: {type: function, status: done, note: "Zig builtin"}
    nfirst: {type: function, status: done, note: "core.clj (next (first coll))"}
    "nil?": {type: function, status: done, note: "Zig builtin"}
    nnext: {type: function, status: done, note: "core.clj (upstream is pure clj)"}
    not: {type: function, status: done, note: "Zig builtin"}
    "not-any?": {type: function, status: done, note: "core.clj (upstream is pure clj)"}
    "not-empty": {type: function, status: done, note: "core.clj (when (seq coll) coll)"}
    "not-every?": {type: function, status: done, note: "core.clj (upstream is pure clj)"}
    "not=": {type: function, status: done, note: "VM intrinsic opcode"}
    ns: {type: macro, status: done, note: 'dynamic var, synced with env.current_ns'}
    "ns-aliases": {type: function, status: done, note: 'dynamic var, synced with env.current_ns'}
    "ns-imports": {type: function, status: done, note: 'dynamic var, synced with env.current_ns'}
    "ns-interns": {type: function, status: done, note: "dynamic var, synced with env.current_ns"}
    "ns-map": {type: function, status: done, note: "dynamic var, synced with env.current_ns"}
    "ns-name": {type: function, status: done, note: "dynamic var, synced with env.current_ns"}
    "ns-publics": {type: function, status: done, note: "dynamic var, synced with env.current_ns"}
    "ns-refers": {type: function, status: done, note: 'dynamic var, synced with env.current_ns'}
    "ns-resolve": {type: function, status: done, note: 'dynamic var, synced with env.current_ns'}
    "ns-unalias": {type: function, status: done, note: 'dynamic var, synced with env.current_ns'}
    "ns-unmap": {type: function, status: done, note: 'dynamic var, synced with env.current_ns'}
    nth: {type: function, status: done, note: "Zig builtin"}
    nthnext: {type: function, status: done, note: "core.clj (upstream is pure clj)"}
    nthrest: {type: function, status: done, note: "core.clj (upstream is pure clj)"}
    num: {type: function, status: done, note: builtin (upstream is pure clj)}
    "number?": {type: function, status: done, note: "Zig builtin"}
    numerator: {type: function, status: skip, note: no Ratio type}
    "object-array": {type: function, status: skip, note: JVM interop}
    "odd?": {type: function, status: done, note: "Zig builtin (upstream is pure clj)"}
    or: {type: macro, status: done, note: "macro in core.clj"}
    parents: {type: function, status: done, note: core.clj hierarchy-aware}
    "parse-boolean": {type: function, status: done, note: "core.clj (upstream is pure clj)"}
    "parse-double": {type: function, status: done, note: builtin (upstream is pure clj)}
    "parse-long": {type: function, status: done, note: builtin (upstream is pure clj)}
    "parse-uuid": {type: function, status: done, note: no UUID type}
    partial: {type: function, status: done, note: "core.clj (upstream is pure clj)"}
    partition: {type: function, status: done, note: "core.clj (upstream is pure clj)"}
    "partition-all": {type: function, status: done, note: "core.clj like partition but includes trailing"}
    "partition-by": {type: function, status: done, note: "core.clj (upstream is pure clj)"}
    partitionv: {type: function, status: done}
    "partitionv-all": {type: function, status: done}
    pcalls: {type: function, status: skip, note: needs future}
    peek: {type: function, status: done, note: "Zig builtin"}
    "persistent!": {type: function, status: done}
    pmap: {type: function, status: skip, note: needs future}
    pop: {type: function, status: done, note: "Zig builtin"}
    "pop!": {type: function, status: done}
    "pop-thread-bindings": {type: function, status: done}
    "pos-int?": {type: function, status: done, note: "Zig builtin"}
    "pos?": {type: function, status: done, note: "Zig builtin"}
    pr: {type: function, status: done, note: "Zig builtin"}
    "pr-str": {type: function, status: done, note: "Zig builtin"}
    "prefer-method": {type: function, status: done}
    prefers: {type: function, status: done}
    "preserving-reduced": {type: function, status: done, note: "private helper for cat"}
    "primitives-classnames": {type: var, status: skip, note: JVM interop}
    print: {type: function, status: done, note: "Zig builtin"}
    "print-ctor": {type: function, status: skip, note: JVM interop}
    "print-dup": {type: var, status: skip, note: JVM interop}
    "print-method": {type: var, status: skip, note: JVM interop}
    "print-simple": {type: function, status: skip, note: JVM interop}
    "print-str": {type: function, status: done, note: "Zig builtin"}
    printf: {type: function, status: done, note: "core.clj (upstream is pure clj)"}
    println: {type: function, status: done, note: "Zig builtin"}
    "println-str": {type: function, status: done, note: "Zig builtin"}
    prn: {type: function, status: done, note: "Zig builtin"}
    "prn-str": {type: function, status: done, note: "Zig builtin"}
    promise: {type: function, status: done, note: "UPSTREAM-DIFF (permanent): atom-based, no blocking deref (no Java concurrency)"}
    proxy: {type: macro, status: skip, note: JVM interop}
    "proxy-call-with-super": {type: function, status: skip, note: JVM interop}
    "proxy-mappings": {type: function, status: skip, note: JVM interop}
    "proxy-name": {type: function, status: skip, note: JVM interop}
    "proxy-super": {type: macro, status: skip, note: JVM interop}
    "push-thread-bindings": {type: function, status: done}
    pvalues: {type: macro, status: skip, note: needs future}
    "qualified-ident?": {type: function, status: done, note: "core.clj (upstream is pure clj)"}
    "qualified-keyword?": {type: function, status: done, note: "core.clj (upstream is pure clj)"}
    "qualified-symbol?": {type: function, status: done, note: "core.clj (upstream is pure clj)"}
    quot: {type: function, status: done, note: "Zig builtin"}
    rand: {type: function, status: done, note: "Zig builtin"}
    "rand-int": {type: function, status: done, note: "Zig builtin"}
    "rand-nth": {type: function, status: done, note: "core.clj (upstream is pure clj)"}
    "random-sample": {type: function, status: done, note: "core.clj (upstream is pure clj)"}
    "random-uuid": {type: function, status: done, note: "builtin; returns string not UUID type"}
    range: {type: function, status: done, note: "Zig builtin"}
    "ratio?": {type: function, status: done, note: builtin (upstream is pure clj)}
    "rational?": {type: function, status: done, note: builtin (upstream is pure clj)}
    rationalize: {type: function, status: skip, note: no Ratio type}
    "re-find": {type: function, status: done, note: "Zig builtin"}
    "re-groups": {type: function, status: skip, note: needs Matcher Value type}
    "re-matcher": {type: function, status: skip, note: needs Matcher Value type}
    "re-matches": {type: function, status: done, note: "Zig builtin"}
    "re-pattern": {type: function, status: done, note: "Zig builtin"}
    "re-seq": {type: function, status: done, note: "Zig builtin"}
    read: {type: function, status: skip, note: needs PushbackReader type}
    read+string: {type: function, status: skip, note: needs PushbackReader type}
    "read-line": {type: function, status: done, note: "Zig builtin"}
    "read-string": {type: function, status: done, note: "Zig builtin"}
    "reader-conditional": {type: function, status: skip, note: needs ReaderConditional Value type}
    "reader-conditional?": {type: function, status: skip, note: "needs ReaderConditional Value type"}
    "realized?": {type: function, status: done, note: "supports delay + lazy-seq"}
    "record?": {type: function, status: done, note: builtin (upstream is pure clj)}
    reduce: {type: function, status: done, note: "core.clj (upstream is pure clj)"}
    "reduce-kv": {type: function, status: done, note: "core.clj via keys+get loop"}
    reduced: {type: function, status: done, note: "Zig builtin"}
    "reduced?": {type: function, status: done, note: "Zig builtin"}
    reductions: {type: function, status: done, note: "dynamic var, synced with env.current_ns"}
    ref: {type: function, status: skip, note: JVM interop}
    "ref-history-count": {type: function, status: skip, note: JVM interop}
    "ref-max-history": {type: function, status: skip, note: JVM interop}
    "ref-min-history": {type: function, status: skip, note: JVM interop}
    "ref-set": {type: function, status: skip, note: JVM interop}
    refer: {type: function, status: done, note: builtin (upstream is pure clj)}
    "refer-clojure": {type: macro, status: done}
    reify: {type: macro, status: skip, note: needs full type/protocol infrastructure}
    "release-pending-sends": {type: function, status: skip, note: JVM interop}
    rem: {type: function, status: done, note: "VM intrinsic opcode"}
    remove: {type: function, status: done, note: "core.clj (upstream is pure clj)"}
    "remove-all-methods": {type: function, status: done, note: builtin (upstream is pure clj)}
    "remove-method": {type: function, status: done, note: builtin (upstream is pure clj)}
    "remove-ns": {type: function, status: done, note: 'dynamic var, synced with env.current_ns'}
    "remove-tap": {type: function, status: done}
    "remove-watch": {type: function, status: done}
    repeat: {type: function, status: done, note: 'lazy, infinite + n-arity'}
    repeatedly: {type: function, status: done, note: "core.clj (upstream is pure clj)"}
    replace: {type: function, status: done, note: "core.clj (upstream is pure clj)"}
    replicate: {type: function, status: done, note: "core.clj (upstream is pure clj)"}
    require: {type: function, status: done, note: 'builtin (upstream is pure clj); no file loading, pre-loaded ns only'}
    "requiring-resolve": {type: function, status: done}
    "reset!": {type: function, status: done, note: "Zig builtin"}
    "reset-meta!": {type: function, status: done, note: "Zig builtin: replaces atom metadata"}
    "reset-vals!": {type: function, status: done, note: "Zig builtin (upstream is pure clj)"}
    resolve: {type: function, status: done}
    rest: {type: function, status: done, note: "Zig builtin"}
    "restart-agent": {type: function, status: skip, note: JVM interop}
    "resultset-seq": {type: function, status: skip, note: JVM interop}
    reverse: {type: function, status: done, note: "portable to clj"}
    "reversible?": {type: function, status: done, note: builtin (upstream is pure clj)}
    rseq: {type: function, status: done, note: builtin (upstream is pure clj)}
    rsubseq: {type: function, status: done, note: builtin (upstream uses Java Sorted interface)}
    "run!": {type: function, status: done, note: "core.clj (upstream is pure clj)"}
    "satisfies?": {type: function, status: done, note: "Zig builtin"}
    second: {type: function, status: done, note: "core.clj (first (next coll))"}
    "select-keys": {type: function, status: done, note: "core.clj (upstream is pure clj)"}
    send: {type: function, status: skip, note: JVM interop}
    "send-off": {type: function, status: skip, note: JVM interop}
    "send-via": {type: function, status: skip, note: JVM interop}
    seq: {type: function, status: done, note: "Zig builtin"}
    "seq-to-map-for-destructuring": {type: function, status: skip, note: 'internal helper, compiler handles'}
    "seq?": {type: function, status: done, note: "Zig builtin"}
    "seqable?": {type: function, status: done, note: builtin (upstream is pure clj)}
    seque: {type: function, status: skip, note: JVM interop}
    sequence: {type: function, status: done, note: 'UPSTREAM-DIFF (permanent): eager via into (upstream uses Java TransformerIterator)'}
    "sequential?": {type: function, status: done, note: "Zig builtin"}
    set: {type: function, status: done, note: "Zig builtin"}
    "set-agent-send-executor!": {type: function, status: skip, note: JVM interop}
    "set-agent-send-off-executor!": {type: function, status: skip, note: JVM interop}
    "set-error-handler!": {type: function, status: skip, note: "JVM interop"}
    "set-error-mode!": {type: function, status: skip, note: "JVM interop"}
    "set-validator!": {type: function, status: done}
    "set?": {type: function, status: done, note: "Zig builtin"}
    short: {type: function, status: done, note: builtin (upstream is pure clj)}
    "short-array": {type: function, status: skip, note: JVM interop}
    shorts: {type: function, status: skip, note: JVM interop}
    shuffle: {type: function, status: done, note: builtin (upstream is pure clj)}
    "shutdown-agents": {type: function, status: skip, note: JVM interop}
    "simple-ident?": {type: function, status: done, note: "core.clj (upstream is pure clj)"}
    "simple-keyword?": {type: function, status: done, note: "core.clj (upstream is pure clj)"}
    "simple-symbol?": {type: function, status: done, note: "core.clj (upstream is pure clj)"}
    slurp: {type: function, status: done, note: "Zig builtin"}
    some: {type: function, status: done, note: "core.clj (upstream is pure clj)"}
    "some->": {type: macro, status: done, note: "macro in core.clj"}
    "some->>": {type: macro, status: done, note: "macro in core.clj"}
    "some-fn": {type: function, status: done, note: "core.clj or-based combinator"}
    "some?": {type: function, status: done, note: "core.clj (not (nil? x))"}
    sort: {type: function, status: done, note: "Zig builtin"}
    "sort-by": {type: function, status: done, note: "Zig builtin"}
    "sorted-map": {type: function, status: done, note: "Zig builtin"}
    "sorted-map-by": {type: function, status: done, note: builtin with custom comparator}
    "sorted-set": {type: function, status: done, note: 'builtin (upstream uses Java TreeSet)'}
    "sorted-set-by": {type: function, status: done, note: builtin with custom comparator}
    "sorted?": {type: function, status: done, note: builtin (upstream is pure clj)}
    "special-symbol?": {type: function, status: done, note: builtin (upstream is pure clj)}
    spit: {type: function, status: done, note: "Zig builtin"}
    "split-at": {type: function, status: done, note: "core.clj (upstream is pure clj)"}
    "split-with": {type: function, status: done, note: "core.clj (upstream is pure clj)"}
    "splitv-at": {type: function, status: done}
    str: {type: function, status: done, note: "portable to clj"}
    "stream-into!": {type: function, status: skip, note: "JVM interop"}
    "stream-reduce!": {type: function, status: skip, note: "JVM interop"}
    "stream-seq!": {type: function, status: skip, note: "JVM interop"}
    "stream-transduce!": {type: function, status: done, note: 'dynamic var, synced with env.current_ns'}
    "string?": {type: function, status: done, note: "Zig builtin"}
    struct: {type: function, status: skip, note: deprecated struct system}
    "struct-map": {type: function, status: skip, note: deprecated struct system}
    subs: {type: function, status: done, note: "Zig builtin"}
    subseq: {type: function, status: done, note: builtin (upstream uses Java Sorted interface)}
    subvec: {type: function, status: done, note: "Zig builtin"}
    supers: {type: function, status: skip, note: JVM interop}
    "swap!": {type: function, status: done, note: "builtin-fn only (D8)"}
    "swap-vals!": {type: function, status: done, note: "Zig builtin (upstream is pure clj)"}
    symbol: {type: function, status: done, note: "Zig builtin"}
    "symbol?": {type: function, status: done, note: "Zig builtin"}
    sync: {type: macro, status: skip, note: JVM interop}
    "tagged-literal": {type: function, status: skip, note: needs TaggedLiteral Value type}
    "tagged-literal?": {type: function, status: skip, note: "needs TaggedLiteral Value type"}
    take: {type: function, status: done, note: "core.clj (upstream is pure clj)"}
    "take-last": {type: function, status: done, note: "core.clj (upstream is pure clj)"}
    "take-nth": {type: function, status: done, note: "core.clj (upstream is pure clj)"}
    "take-while": {type: function, status: done, note: "core.clj loop+pred"}
    "tap>": {type: function, status: done}
    test: {type: function, status: done, note: "core.clj (upstream is pure clj)"}
    "the-ns": {type: function, status: done, note: "dynamic var, synced with env.current_ns"}
    "thread-bound?": {type: function, status: done}
    time: {type: macro, status: done, note: macro using __nano-time}
    "to-array": {type: function, status: skip, note: JVM interop}
    "to-array-2d": {type: function, status: skip, note: JVM interop}
    trampoline: {type: function, status: done, note: "core.clj (upstream is pure clj)"}
    transduce: {type: function, status: done, note: 'dynamic var, synced with env.current_ns'}
    transient: {type: function, status: done}
    "tree-seq": {type: function, status: done, note: "core.clj (upstream is pure clj)"}
    "true?": {type: function, status: done, note: "core.clj (= x true)"}
    type: {type: function, status: done, note: "Zig builtin returns keyword"}
    "unchecked-add": {type: function, status: done, note: "core.clj wrapper (no overflow in Zig)"}
    "unchecked-add-int": {type: function, status: done, note: "core.clj wrapper (no overflow in Zig)"}
    "unchecked-byte": {type: function, status: done}
    "unchecked-char": {type: function, status: done}
    "unchecked-dec": {type: function, status: done, note: "core.clj wrapper (no overflow in Zig)"}
    "unchecked-dec-int": {type: function, status: done, note: "core.clj wrapper (no overflow in Zig)"}
    "unchecked-divide-int": {type: function, status: done}
    "unchecked-double": {type: function, status: done}
    "unchecked-float": {type: function, status: done}
    "unchecked-inc": {type: function, status: done, note: "core.clj wrapper (no overflow in Zig)"}
    "unchecked-inc-int": {type: function, status: done, note: "core.clj wrapper (no overflow in Zig)"}
    "unchecked-int": {type: function, status: done}
    "unchecked-long": {type: function, status: done}
    "unchecked-multiply": {type: function, status: done, note: "core.clj wrapper (no overflow in Zig)"}
    "unchecked-multiply-int": {type: function, status: done, note: "core.clj wrapper (no overflow in Zig)"}
    "unchecked-negate": {type: function, status: done, note: "core.clj wrapper (no overflow in Zig)"}
    "unchecked-negate-int": {type: function, status: done, note: "core.clj wrapper (no overflow in Zig)"}
    "unchecked-remainder-int": {type: function, status: done}
    "unchecked-short": {type: function, status: done}
    "unchecked-subtract": {type: function, status: done, note: "core.clj wrapper (no overflow in Zig)"}
    "unchecked-subtract-int": {type: function, status: done, note: "core.clj wrapper (no overflow in Zig)"}
    underive: {type: function, status: done, note: core.clj hierarchy-aware}
    unquote: {type: var, status: done}
    "unquote-splicing": {type: var, status: done}
    unreduced: {type: function, status: done, note: "Zig builtin"}
    "unsigned-bit-shift-right": {type: function, status: done, note: "dynamic var, synced with env.current_ns"}
    update: {type: function, status: done, note: "core.clj (upstream is pure clj)"}
    "update-in": {type: function, status: done, note: "core.clj (upstream is pure clj)"}
    "update-keys": {type: function, status: done, note: "core.clj with transient"}
    "update-proxy": {type: function, status: skip, note: JVM interop}
    "update-vals": {type: function, status: done, note: "core.clj with transient"}
    "uri?": {type: function, status: skip, note: "no URI type"}
    use: {type: function, status: done, note: 'builtin (upstream is pure clj); no file loading, pre-loaded ns only'}
    "uuid?": {type: function, status: skip, note: "no UUID type"}
    val: {type: function, status: done, note: "Zig builtin"}
    vals: {type: function, status: done, note: "Zig builtin"}
    "var-get": {type: function, status: done, note: T11.2}
    "var-set": {type: function, status: done, note: T11.2}
    "var?": {type: function, status: done, note: T11.2}
    "vary-meta": {type: function, status: done, note: 'core.clj: (with-meta obj (apply f (meta obj) args))'}
    vec: {type: function, status: done, note: "Zig builtin"}
    vector: {type: function, status: done, note: "Zig builtin"}
    "vector-of": {type: function, status: skip, note: JVM interop}
    "vector?": {type: function, status: done, note: "Zig builtin"}
    "volatile!": {type: function, status: done, note: "Zig builtin"}
    "volatile?": {type: function, status: done, note: "Zig builtin"}
    "vreset!": {type: function, status: done, note: "Zig builtin"}
    "vswap!": {type: macro, status: done, note: "core.clj macro"}
    when: {type: macro, status: done, note: "macro in core.clj"}
    "when-first": {type: macro, status: done, note: "macro in core.clj"}
    "when-let": {type: macro, status: done}
    "when-not": {type: macro, status: done, note: "macro in core.clj"}
    "when-some": {type: macro, status: done}
    while: {type: macro, status: done, note: "core.clj loop+when+recur"}
    "with-bindings": {type: macro, status: done}
    "with-bindings*": {type: function, status: done}
    "with-in-str": {type: macro, status: skip, note: needs string reader + *in* input}
    "with-loading-context": {type: macro, status: skip, note: JVM classloader}
    "with-local-vars": {type: macro, status: skip, note: needs Var.create()}
    "with-meta": {type: function, status: done, note: 'Zig builtin: returns copy with new metadata'}
    "with-open": {type: macro, status: skip, note: needs .close interop}
    "with-out-str": {type: macro, status: done}
    "with-precision": {type: macro, status: skip, note: JVM BigDecimal}
    "with-redefs": {type: macro, status: done}
    "with-redefs-fn": {type: function, status: done}
    "xml-seq": {type: function, status: done, note: "core.clj (upstream is pure clj)"}
    "zero?": {type: function, status: done, note: "Zig builtin"}
    zipmap: {type: function, status: done, note: "Zig builtin"}
    global-hierarchy:
      type: var
      status: done
      note: core.clj private hierarchy atom
  clojure_core_protocols:
    CollReduce: {type: var, status: todo}
    Datafiable: {type: var, status: todo}
    IKVReduce: {type: var, status: todo}
    InternalReduce: {type: var, status: todo}
    Navigable: {type: var, status: todo}
    "coll-reduce": {type: function, status: todo}
    datafy: {type: function, status: todo}
    "internal-reduce": {type: function, status: todo}
    "iterator-reduce!": {type: function, status: todo}
    "kv-reduce": {type: function, status: todo}
    nav: {type: function, status: todo}
  clojure_core_reducers:
    "->Cat": {type: function, status: todo}
    CollFold: {type: var, status: todo}
    "append!": {type: function, status: todo}
    cat: {type: function, status: todo}
    "coll-fold": {type: function, status: todo}
    drop: {type: function, status: todo}
    filter: {type: function, status: todo}
    fjtask: {type: function, status: todo}
    flatten: {type: function, status: todo}
    fold: {type: function, status: todo}
    foldcat: {type: function, status: todo}
    folder: {type: function, status: todo}
    map: {type: function, status: todo}
    mapcat: {type: function, status: todo}
    monoid: {type: function, status: todo}
    pool: {type: var, status: todo}
    reduce: {type: function, status: todo}
    reducer: {type: function, status: todo}
    remove: {type: function, status: todo}
    take: {type: function, status: todo}
    "take-while": {type: function, status: done, note: "core.clj loop+pred"}
  clojure_core_server:
    "*session*": {type: dynamic-var, status: todo}
    "io-prepl": {type: function, status: todo}
    prepl: {type: function, status: todo}
    "remote-prepl": {type: function, status: todo}
    repl: {type: function, status: todo}
    "repl-init": {type: function, status: todo}
    "repl-read": {type: function, status: todo}
    "start-server": {type: function, status: todo}
    "start-servers": {type: function, status: todo}
    "stop-server": {type: function, status: todo}
    "stop-servers": {type: function, status: todo}
  clojure_core_specs_alpha:
    "even-number-of-forms?": {type: function, status: todo}
  clojure_data:
    Diff: {type: var, status: todo}
    EqualityPartition: {type: var, status: todo}
    diff: {type: function, status: todo}
    "diff-similar": {type: function, status: todo}
    "equality-partition": {type: function, status: todo}
  clojure_datafy:
    datafy: {type: function, status: todo}
    nav: {type: function, status: todo}
  clojure_edn:
    read: {type: function, status: todo}
    "read-string": {type: function, status: todo}
  clojure_inspector:
    "atom?": {type: function, status: todo}
    "collection-tag": {type: function, status: todo}
    "get-child": {type: var, status: todo}
    "get-child-count": {type: var, status: todo}
    inspect: {type: function, status: todo}
    "inspect-table": {type: function, status: todo}
    "inspect-tree": {type: function, status: todo}
    "is-leaf": {type: var, status: todo}
    "list-model": {type: function, status: todo}
    "list-provider": {type: var, status: todo}
    "old-table-model": {type: function, status: todo}
    "table-model": {type: var, status: todo}
    "tree-model": {type: function, status: todo}
  clojure_instant:
    "parse-timestamp": {type: function, status: todo}
    "read-instant-calendar": {type: function, status: todo}
    "read-instant-date": {type: function, status: todo}
    "read-instant-timestamp": {type: function, status: todo}
    validated: {type: function, status: todo}
  clojure_java_browse:
    "*open-url-script*": {type: dynamic-var, status: todo}
    "browse-url": {type: function, status: todo}
  clojure_java_io:
    Coercions: {type: var, status: todo}
    IOFactory: {type: var, status: todo}
    "as-file": {type: function, status: todo}
    "as-relative-path": {type: function, status: todo}
    "as-url": {type: function, status: todo}
    copy: {type: function, status: todo}
    "default-streams-impl": {type: var, status: todo}
    "delete-file": {type: function, status: todo}
    file: {type: function, status: todo}
    "input-stream": {type: function, status: todo}
    "make-input-stream": {type: function, status: todo}
    "make-output-stream": {type: function, status: todo}
    "make-parents": {type: function, status: todo}
    "make-reader": {type: function, status: todo}
    "make-writer": {type: function, status: todo}
    "output-stream": {type: function, status: todo}
    reader: {type: function, status: todo}
    resource: {type: function, status: todo}
    writer: {type: function, status: todo}
  clojure_java_javadoc:
    "*core-java-api*": {type: dynamic-var, status: todo}
    "*feeling-lucky*": {type: dynamic-var, status: todo}
    "*feeling-lucky-url*": {type: dynamic-var, status: todo}
    "*local-javadocs*": {type: dynamic-var, status: todo}
    "*remote-javadocs*": {type: dynamic-var, status: todo}
    "add-local-javadoc": {type: function, status: todo}
    "add-remote-javadoc": {type: function, status: todo}
    javadoc: {type: function, status: todo}
  clojure_java_shell:
    "*sh-dir*": {type: dynamic-var, status: todo}
    "*sh-env*": {type: dynamic-var, status: todo}
    sh: {type: function, status: todo}
    "with-sh-dir": {type: macro, status: todo}
    "with-sh-env": {type: macro, status: todo}
  clojure_main:
    demunge: {type: function, status: todo}
    "err->msg": {type: function, status: todo}
    "ex-str": {type: function, status: todo}
    "ex-triage": {type: function, status: todo}
    "load-script": {type: function, status: todo}
    main: {type: function, status: todo}
    "renumbering-read": {type: function, status: todo}
    repl: {type: function, status: todo}
    "repl-caught": {type: function, status: todo}
    "repl-exception": {type: function, status: todo}
    "repl-prompt": {type: function, status: todo}
    "repl-read": {type: function, status: todo}
    "repl-requires": {type: var, status: todo}
    "report-error": {type: function, status: todo}
    "root-cause": {type: function, status: todo}
    "skip-if-eol": {type: function, status: todo}
    "skip-whitespace": {type: function, status: todo}
    "stack-element-str": {type: function, status: todo}
    "with-bindings": {type: macro, status: todo}
    "with-read-known": {type: macro, status: todo}
  clojure_math:
    E: {type: var, status: todo}
    "IEEE-remainder": {type: function, status: todo}
    PI: {type: var, status: todo}
    acos: {type: function, status: todo}
    "add-exact": {type: function, status: todo}
    asin: {type: function, status: todo}
    atan: {type: function, status: todo}
    atan2: {type: function, status: todo}
    cbrt: {type: function, status: todo}
    ceil: {type: function, status: todo}
    "copy-sign": {type: function, status: todo}
    cos: {type: function, status: todo}
    cosh: {type: function, status: todo}
    "decrement-exact": {type: function, status: todo}
    exp: {type: function, status: todo}
    expm1: {type: function, status: todo}
    floor: {type: function, status: todo}
    "floor-div": {type: function, status: todo}
    "floor-mod": {type: function, status: todo}
    "get-exponent": {type: function, status: todo}
    hypot: {type: function, status: todo}
    "increment-exact": {type: function, status: todo}
    log: {type: function, status: todo}
    log10: {type: function, status: todo}
    log1p: {type: function, status: todo}
    "multiply-exact": {type: function, status: todo}
    "negate-exact": {type: function, status: todo}
    "next-after": {type: function, status: todo}
    "next-down": {type: function, status: todo}
    "next-up": {type: function, status: todo}
    pow: {type: function, status: todo}
    random: {type: function, status: todo}
    rint: {type: function, status: todo}
    round: {type: function, status: todo}
    scalb: {type: function, status: todo}
    signum: {type: function, status: todo}
    sin: {type: function, status: todo}
    sinh: {type: function, status: todo}
    sqrt: {type: function, status: todo}
    "subtract-exact": {type: function, status: todo}
    tan: {type: function, status: todo}
    tanh: {type: function, status: todo}
    "to-degrees": {type: function, status: todo}
    "to-radians": {type: function, status: todo}
    ulp: {type: function, status: todo}
  clojure_pprint:
    "*print-base*": {type: dynamic-var, status: todo}
    "*print-miser-width*": {type: dynamic-var, status: todo}
    "*print-pprint-dispatch*": {type: dynamic-var, status: todo}
    "*print-pretty*": {type: dynamic-var, status: todo}
    "*print-radix*": {type: dynamic-var, status: todo}
    "*print-right-margin*": {type: dynamic-var, status: todo}
    "*print-suppress-namespaces*": {type: dynamic-var, status: todo}
    "cl-format": {type: function, status: todo}
    "code-dispatch": {type: var, status: todo}
    formatter: {type: macro, status: todo}
    "formatter-out": {type: macro, status: todo}
    "fresh-line": {type: function, status: todo}
    "get-pretty-writer": {type: function, status: todo}
    pp: {type: macro, status: todo}
    pprint: {type: function, status: todo}
    "pprint-indent": {type: function, status: todo}
    "pprint-logical-block": {type: macro, status: todo}
    "pprint-newline": {type: function, status: todo}
    "pprint-tab": {type: function, status: todo}
    "print-length-loop": {type: macro, status: todo}
    "print-table": {type: function, status: todo}
    "set-pprint-dispatch": {type: function, status: todo}
    "simple-dispatch": {type: var, status: todo}
    "with-pprint-dispatch": {type: macro, status: todo}
    write: {type: function, status: todo}
    "write-out": {type: function, status: todo}
  clojure_reflect:
    "->AsmReflector": {type: function, status: todo}
    "->Constructor": {type: function, status: todo}
    "->Field": {type: function, status: todo}
    "->JavaReflector": {type: function, status: todo}
    "->Method": {type: function, status: todo}
    ClassResolver: {type: var, status: todo}
    Reflector: {type: var, status: todo}
    TypeReference: {type: var, status: todo}
    "do-reflect": {type: function, status: todo}
    "flag-descriptors": {type: var, status: todo}
    "map->Constructor": {type: function, status: todo}
    "map->Field": {type: function, status: todo}
    "map->Method": {type: function, status: todo}
    reflect: {type: function, status: todo}
    "resolve-class": {type: function, status: todo}
    "type-reflect": {type: function, status: todo}
    typename: {type: function, status: todo}
  clojure_repl:
    apropos: {type: function, status: todo}
    demunge: {type: function, status: todo}
    dir: {type: macro, status: todo}
    "dir-fn": {type: function, status: todo}
    doc: {type: macro, status: todo}
    "find-doc": {type: function, status: todo}
    pst: {type: function, status: todo}
    "root-cause": {type: function, status: todo}
    "set-break-handler!": {type: function, status: todo}
    source: {type: macro, status: todo}
    "source-fn": {type: function, status: todo}
    "stack-element-str": {type: function, status: todo}
    "thread-stopper": {type: function, status: todo}
  clojure_set:
    difference: {type: function, status: done}
    index: {type: function, status: done}
    intersection: {type: function, status: done}
    join: {type: function, status: done}
    "map-invert": {type: function, status: done}
    project: {type: function, status: done}
    rename: {type: function, status: done}
    "rename-keys": {type: function, status: done}
    select: {type: function, status: done}
    "subset?": {type: function, status: done}
    "superset?": {type: function, status: done}
    union: {type: function, status: done}
  clojure_spec_alpha:
    "&": {type: macro, status: todo}
    "*": {type: macro, status: todo}
    "*coll-check-limit*": {type: dynamic-var, status: todo}
    "*coll-error-limit*": {type: dynamic-var, status: todo}
    "*compile-asserts*": {type: dynamic-var, status: todo}
    "*explain-out*": {type: function, status: todo}
    "*fspec-iterations*": {type: dynamic-var, status: todo}
    "*recursion-limit*": {type: dynamic-var, status: todo}
    "+": {type: macro, status: todo}
    "?": {type: macro, status: todo}
    Spec: {type: var, status: todo}
    Specize: {type: var, status: todo}
    abbrev: {type: function, status: todo}
    alt: {type: macro, status: todo}
    "alt-impl": {type: function, status: todo}
    "amp-impl": {type: function, status: todo}
    and: {type: macro, status: todo}
    "and-spec-impl": {type: function, status: todo}
    assert: {type: macro, status: todo}
    "assert*": {type: function, status: todo}
    cat: {type: macro, status: todo}
    "cat-impl": {type: function, status: todo}
    "check-asserts": {type: function, status: todo}
    "check-asserts?": {type: function, status: todo}
    "coll-of": {type: macro, status: todo}
    conform: {type: function, status: todo}
    "conform*": {type: function, status: todo}
    conformer: {type: macro, status: todo}
    def: {type: macro, status: todo}
    "def-impl": {type: function, status: todo}
    describe: {type: function, status: todo}
    "describe*": {type: function, status: todo}
    "double-in": {type: macro, status: todo}
    every: {type: macro, status: todo}
    "every-impl": {type: function, status: todo}
    "every-kv": {type: macro, status: todo}
    exercise: {type: function, status: todo}
    "exercise-fn": {type: function, status: todo}
    explain: {type: function, status: todo}
    "explain*": {type: function, status: todo}
    "explain-data": {type: function, status: todo}
    "explain-data*": {type: function, status: todo}
    "explain-out": {type: function, status: todo}
    "explain-printer": {type: function, status: todo}
    "explain-str": {type: function, status: todo}
    fdef: {type: macro, status: todo}
    form: {type: function, status: todo}
    fspec: {type: macro, status: todo}
    "fspec-impl": {type: function, status: todo}
    gen: {type: function, status: todo}
    "gen*": {type: function, status: todo}
    "get-spec": {type: function, status: todo}
    "inst-in": {type: macro, status: todo}
    "inst-in-range?": {type: function, status: todo}
    "int-in": {type: macro, status: todo}
    "int-in-range?": {type: function, status: todo}
    "invalid?": {type: function, status: todo}
    keys: {type: macro, status: todo}
    "keys*": {type: macro, status: todo}
    "map-of": {type: macro, status: todo}
    "map-spec-impl": {type: function, status: todo}
    "maybe-impl": {type: function, status: todo}
    merge: {type: macro, status: todo}
    "merge-spec-impl": {type: function, status: todo}
    "multi-spec": {type: macro, status: todo}
    "multi-spec-impl": {type: function, status: todo}
    nilable: {type: macro, status: todo}
    "nilable-impl": {type: function, status: todo}
    nonconforming: {type: function, status: todo}
    or: {type: macro, status: todo}
    "or-spec-impl": {type: function, status: todo}
    "regex-spec-impl": {type: function, status: todo}
    "regex?": {type: function, status: todo}
    registry: {type: function, status: todo}
    rep+impl: {type: function, status: todo}
    "rep-impl": {type: function, status: todo}
    spec: {type: macro, status: todo}
    "spec-impl": {type: function, status: todo}
    "spec?": {type: function, status: todo}
    "specize*": {type: function, status: todo}
    tuple: {type: macro, status: todo}
    "tuple-impl": {type: function, status: todo}
    unform: {type: function, status: todo}
    "unform*": {type: function, status: todo}
    "valid?": {type: function, status: todo}
    "with-gen": {type: function, status: todo}
    "with-gen*": {type: function, status: todo}
  clojure_spec_gen_alpha:
    any: {type: function, status: todo}
    "any-printable": {type: function, status: todo}
    bind: {type: function, status: todo}
    boolean: {type: function, status: done, note: "core.clj (if x true false)"}
    bytes: {type: function, status: todo}
    cat: {type: function, status: todo}
    char: {type: function, status: todo}
    "char-alpha": {type: function, status: todo}
    "char-alphanumeric": {type: function, status: todo}
    "char-ascii": {type: function, status: todo}
    choose: {type: function, status: todo}
    delay: {type: macro, status: done, note: "core.clj map+atom memoization"}
    "delay-impl": {type: function, status: todo}
    double: {type: function, status: todo}
    "double*": {type: function, status: todo}
    elements: {type: function, status: todo}
    fmap: {type: function, status: todo}
    "for-all*": {type: function, status: todo}
    frequency: {type: function, status: todo}
    "gen-for-name": {type: function, status: todo}
    "gen-for-pred": {type: function, status: todo}
    generate: {type: function, status: todo}
    "hash-map": {type: function, status: todo}
    int: {type: function, status: todo}
    keyword: {type: function, status: todo}
    "keyword-ns": {type: function, status: todo}
    "large-integer": {type: function, status: todo}
    "large-integer*": {type: function, status: todo}
    "lazy-combinator": {type: macro, status: todo}
    "lazy-combinators": {type: macro, status: todo}
    "lazy-prim": {type: macro, status: todo}
    "lazy-prims": {type: macro, status: todo}
    list: {type: function, status: todo}
    map: {type: function, status: todo}
    "not-empty": {type: function, status: done, note: "core.clj (when (seq coll) coll)"}
    "one-of": {type: function, status: todo}
    "quick-check": {type: function, status: todo}
    ratio: {type: function, status: todo}
    return: {type: function, status: todo}
    sample: {type: function, status: todo}
    set: {type: function, status: todo}
    shuffle: {type: function, status: todo}
    "simple-type": {type: function, status: todo}
    "simple-type-printable": {type: function, status: todo}
    string: {type: function, status: todo}
    "string-alphanumeric": {type: function, status: todo}
    "string-ascii": {type: function, status: todo}
    "such-that": {type: function, status: todo}
    symbol: {type: function, status: todo}
    "symbol-ns": {type: function, status: todo}
    tuple: {type: function, status: todo}
    uuid: {type: function, status: todo}
    vector: {type: function, status: todo}
    "vector-distinct": {type: function, status: todo}
  clojure_stacktrace:
    e: {type: function, status: todo}
    "print-cause-trace": {type: function, status: todo}
    "print-stack-trace": {type: function, status: todo}
    "print-throwable": {type: function, status: todo}
    "print-trace-element": {type: function, status: todo}
    "root-cause": {type: function, status: todo}
  clojure_string:
    "blank?": {type: function, status: done}
    capitalize: {type: function, status: done, note: builtin (upstream is pure clj)}
    "ends-with?": {type: function, status: done}
    escape: {type: function, status: done, note: builtin (upstream is pure clj)}
    "includes?": {type: function, status: done}
    "index-of": {type: function, status: done, note: builtin (upstream uses .indexOf)}
    join: {type: function, status: done}
    "last-index-of": {type: function, status: done, note: builtin (upstream uses .lastIndexOf)}
    "lower-case": {type: function, status: done}
    "re-quote-replacement": {type: function, status: done, note: builtin (upstream is pure clj)}
    replace: {type: function, status: done, note: "core.clj (upstream is pure clj)"}
    "replace-first": {type: function, status: done, note: builtin (upstream is pure clj)}
    reverse: {type: function, status: done}
    split: {type: function, status: done}
    "split-lines": {type: function, status: done, note: builtin (upstream is pure clj)}
    "starts-with?": {type: function, status: done}
    trim: {type: function, status: done}
    "trim-newline": {type: function, status: done}
    triml: {type: function, status: done}
    trimr: {type: function, status: done}
    "upper-case": {type: function, status: done}
  clojure_template:
    "apply-template": {type: function, status: done}
    "do-template": {type: macro, status: done}
  clojure_test:
    "*initial-report-counters*": {type: dynamic-var, status: todo}
    "*load-tests*": {type: dynamic-var, status: todo}
    "*report-counters*": {type: dynamic-var, status: todo}
    "*stack-trace-depth*": {type: dynamic-var, status: todo}
    "*test-out*": {type: dynamic-var, status: todo}
    "*testing-contexts*": {type: dynamic-var, status: done}
    "*testing-vars*": {type: dynamic-var, status: todo}
    are: {type: macro, status: done}
    "assert-any": {type: function, status: todo}
    "assert-expr": {type: var, status: todo}
    "assert-predicate": {type: function, status: todo}
    "compose-fixtures": {type: function, status: done}
    deftest: {type: macro, status: done}
    "deftest-": {type: macro, status: todo}
    "do-report": {type: function, status: todo}
    "file-position": {type: function, status: todo}
    "function?": {type: function, status: todo}
    "get-possibly-unbound-var": {type: function, status: todo}
    "inc-report-counter": {type: function, status: todo}
    is: {type: macro, status: done}
    "join-fixtures": {type: function, status: done}
    report: {type: dynamic-var, status: done}
    "run-all-tests": {type: function, status: todo}
    "run-test": {type: macro, status: todo}
    "run-test-var": {type: function, status: todo}
    "run-tests": {type: function, status: done}
    "set-test": {type: macro, status: todo}
    "successful?": {type: function, status: todo}
    "test-all-vars": {type: function, status: done}
    "test-ns": {type: function, status: todo}
    "test-var": {type: function, status: done}
    "test-vars": {type: function, status: done}
    testing: {type: macro, status: done}
    "testing-contexts-str": {type: function, status: done}
    "testing-vars-str": {type: function, status: todo}
    "try-expr": {type: macro, status: todo}
    "use-fixtures": {type: var, status: done}
    "with-test": {type: macro, status: todo}
    "with-test-out": {type: macro, status: todo}
  clojure_uuid:
  clojure_walk:
    "keywordize-keys": {type: function, status: done}
    "macroexpand-all": {type: function, status: done}
    postwalk: {type: function, status: done}
    "postwalk-demo": {type: function, status: todo}
    "postwalk-replace": {type: function, status: done}
    prewalk: {type: function, status: done}
    "prewalk-demo": {type: function, status: todo}
    "prewalk-replace": {type: function, status: done}
    "stringify-keys": {type: function, status: done}
    walk: {type: function, status: done}
  clojure_zip:
    "append-child": {type: function, status: todo}
    "branch?": {type: function, status: todo}
    children: {type: function, status: todo}
    down: {type: function, status: todo}
    edit: {type: function, status: todo}
    "end?": {type: function, status: todo}
    "insert-child": {type: function, status: todo}
    "insert-left": {type: function, status: todo}
    "insert-right": {type: function, status: todo}
    left: {type: function, status: todo}
    leftmost: {type: function, status: todo}
    lefts: {type: function, status: todo}
    "make-node": {type: function, status: todo}
    next: {type: function, status: todo}
    node: {type: function, status: todo}
    path: {type: function, status: todo}
    prev: {type: function, status: todo}
    remove: {type: function, status: todo}
    replace: {type: function, status: todo}
    right: {type: function, status: todo}
    rightmost: {type: function, status: todo}
    rights: {type: function, status: todo}
    root: {type: function, status: todo}
    "seq-zip": {type: function, status: todo}
    up: {type: function, status: todo}
    "vector-zip": {type: function, status: todo}
    "xml-zip": {type: function, status: todo}
    zipper: {type: function, status: todo}
