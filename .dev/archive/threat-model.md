# ClojureWasm Threat Model

Documented as part of Phase 80 (Crash Hardening & Fuzzing).

## Trust Boundaries

```
┌──────────────────────────────────────────────┐
│  User Code (Clojure source)                  │
│  ─ Untrusted input                           │
│  ─ Read by Reader → Analyzer → Compiler → VM │
├──────────────────────────────────────────────┤
│  CW Runtime                                  │
│  ─ Trusted implementation                    │
│  ─ Zig compiled with ReleaseSafe             │
│  ─ GC with mark-and-sweep + mutex            │
├──────────────────────────────────────────────┤
│  Wasm Modules (.wasm files)                  │
│  ─ Semi-trusted (user-provided)              │
│  ─ Sandboxed by zwasm VM                     │
│  ─ WASI capabilities: all (user controls)    │
├──────────────────────────────────────────────┤
│  Host OS (filesystem, network, processes)    │
│  ─ Trusted                                   │
│  ─ CW has full OS access (not sandboxed)     │
└──────────────────────────────────────────────┘
```

## Threat Categories

### T1: Malicious Clojure Source Code

**Attack surface**: User code evaluated via `-e`, file execution, REPL, `eval`, `load-string`.

| Threat | Mitigation | Status |
|--------|------------|--------|
| Stack overflow via deep recursion | VM: 1024 frames, TreeWalk: 512 calls | Protected |
| Stack overflow via deep nesting | Reader: depth limit 1024, Analyzer: depth limit 1024 | Protected |
| OOM via huge string literal | Reader: 1MB string limit | Protected |
| OOM via huge collection literal | Reader: 100K element limit | Protected |
| OOM via format width/precision | format: 10K cap on width/precision | Protected |
| OOM via str concatenation | str: 10MB output limit | Protected |
| OOM via repeat | repeat: 1M element limit | Protected |
| Regex catastrophic backtracking | Matcher: 10K recursion depth limit | Protected |
| Infinite loop | Not mitigated (expected Clojure behavior) | By design |
| Infinite lazy-seq realization | Lazy evaluation; no forced realization | By design |
| File system access via slurp/spit | Full OS access (CW is not sandboxed) | By design |
| Process execution via shell | Full OS access | By design |
| Network access via HTTP | Full OS access | By design |
| eval injection | Expected Clojure behavior (eval is first-class) | By design |
| require path traversal | Namespace name sanitization (dots/hyphens only) | Protected |

### T2: Malicious Wasm Modules

**Attack surface**: `.wasm` files loaded via `wasm/load-module`.

| Threat | Mitigation | Status |
|--------|------------|--------|
| Memory escape from Wasm sandbox | zwasm enforces linear memory bounds | Protected |
| Host function abuse | WASI capability flags control access | Protected |
| Wasm module OOM | zwasm uses smp_allocator (separate from GC) | Protected |
| Wasm infinite loop | Not mitigated (no fuel/gas metering) | Known limitation |
| Wasm code injection into CW | Opaque wrapper — no bytecode injection path | Protected |

### T3: GC Attacks (via crafted allocation patterns)

| Threat | Mitigation | Status |
|--------|------------|--------|
| Use-after-free | HashMap-based tracking, root set tracing | Protected |
| Double free | HashMap remove-before-free pattern | Protected |
| GC pause amplification | Adaptive threshold (2x bytes_allocated) | Mitigated |
| Concurrent GC corruption | Mutex protection on all GC state | Protected |

### T4: VM Internal Attacks (requires compiler bug)

CW does not accept external bytecode. All bytecode is generated by CW's compiler.
These threats require a bug in the compiler to produce invalid bytecode.

| Threat | Mitigation | Status |
|--------|------------|--------|
| Stack underflow | Debug assertions on pop/peek | Protected (debug) |
| Invalid jump target | Bounds check on all jump instructions | Protected |
| Invalid catch IP | Bounds check on try_begin handler registration | Protected |
| Type confusion | Tag-based dispatch; NaN boxing encoding | Protected |

### T5: Supply Chain

| Threat | Mitigation | Status |
|--------|------------|--------|
| Compromised zwasm dependency | Pinned version + hash verification in build.zig.zon | Protected |
| Build reproducibility | Zig deterministic builds | Protected |

## Design Decisions

1. **CW is not a sandbox.** User Clojure code has full OS access (filesystem, network, processes). This matches JVM Clojure's security model.

2. **Wasm modules are sandboxed.** The zwasm VM enforces linear memory isolation. WASI capabilities control host access.

3. **No external bytecode.** CW's VM only executes bytecode from its own compiler. There is no `load-bytecode` API.

4. **ReleaseSafe always.** Production builds use ReleaseSafe which preserves bounds checks, overflow detection, and safety assertions.

5. **Resource limits are configurable.** Reader limits (depth, string size, collection count) can be adjusted for different use cases (fuzzing uses tighter limits).

## Known Limitations

- No timeout/fuel mechanism for infinite loops or infinite Wasm execution
- No memory quota for individual Clojure expressions
- No network sandboxing
- WASI defaults to all capabilities (trusted module assumption)
